#!/usr/bin/env node

const fs = require('fs')
const zip = require('jszip')
const xml = require('xml2js')
const formula = require('formulajs')

const version = require('../package.json').version
const date = formula.DATEVALUE(new Date().toString())

const dryRun = false

const run = async () => {
  await Promise.all([
    update('finbox.functions.xlam', { dryRun }),
    update('finbox.install.xlam', { dryRun })
  ])
}

const update = async (filename, { dryRun } = {}) => {
  const isOpen = fs.existsSync(`~$${filename}`)
  if (isOpen) {
    throw new Error(`[${filename}] File is in use`)
  }

  const xlam = fs.readFileSync(filename)
  const addin = await zip.loadAsync(xlam)

  let parser = promised(new xml.Parser())
  let book = await addin
    .file('xl/workbook.xml')
    .async('string')
  let bookJson = await parser.parseAsync(book)

  const versionRange = getAddress(bookJson, 'AppVersion')
  const dateRange = getAddress(bookJson, 'ReleaseDate')
  bookJson.workbook.sheets.forEach((s) => s.sheet.forEach((s) => {
    if (s.$.name === versionRange.sheet) versionRange.sheet = s.$['r:id']
    if (s.$.name === dateRange.sheet) dateRange.sheet = s.$['r:id']
  }))

  parser.reset()
  let rels = await addin
    .file('xl/_rels/workbook.xml.rels')
    .async('string')
  rels = await parser.parseAsync(rels)

  const sheets = [ versionRange.sheet, dateRange.sheet ]
  const sheetFiles = rels.Relationships.Relationship
    .filter((r) => sheets.includes(r.$.Id))
    .map((r) => r.$.Target)

  if (sheetFiles.length > 1) {
    throw new Error(`[${filename}] Expected version and date in same sheet`)
  }

  parser.reset()
  let sheet = await addin
    .file(`xl/${sheetFiles[0]}`)
    .async('string')
  const sheetJson = await parser.parseAsync(sheet)
  const sheetCells = sheetJson.worksheet.sheetData[0].row.reduce((c, r) => c.concat(r.c), [])

  const versionCell = sheetCells.filter((c) => c.$.r === versionRange.cell)

  if (versionCell.length !== 1) {
    throw new Error(`[${filename}] Could not find version cell`)
  }

  if (versionCell[0].$.t !== 's') {
    throw new Error(`[${filename}] Version is not specified in shared string`)
  }

  parser.reset()
  let strings = await addin
    .file('xl/sharedStrings.xml')
    .async('string')
  const stringsJson = await parser.parseAsync(strings)
  const sst = stringsJson.sst.si.map((s) => s.t.pop())

  const calcFind = new RegExp('calcMode=".*?"')
  const calcReplace = ""
  book = book.replace(calcFind, calcReplace)
  addin.file('xl/workbook.xml', book)

  const versionIndex = +(versionCell[0].v[0])
  const versionString = sst[versionIndex]

  const versionFind = `<si><t>${versionString}</t></si>`
  const versionReplace = `<si><t>${version}</t></si>`
  strings = strings.replace(versionFind, versionReplace)
  addin.file('xl/sharedStrings.xml', strings)

  const dateExp = new RegExp(`(<c[^>]*r="${dateRange.cell}"[^>]*><v>)([0-9.]+)(</v></c>)`)
  const dateTag = dateExp.exec(sheet)

  if (!dateTag || !dateTag[2]) {
    throw new Error(`[${filename}] Could not find date cell`)
  }

  const dateFind = `${dateTag[0]}`
  const dateReplace = `${dateTag[1]}${date}${dateTag[3]}`
  sheet = sheet.replace(dateFind, dateReplace)
  addin.file(`xl/${sheetFiles[0]}`, sheet)

  parser.reset()
  let props = await addin
    .file('docProps/core.xml')
    .async('string')

  const titleExp = new RegExp('<dc:title>(.*)</dc:title>')
  const titleTag = titleExp.exec(props)

  const titleFind = `<dc:title>${titleTag[1]}</dc:title>`
  const titleReplace = `<dc:title>${titleTag[1].replace(/v[0-9.A-Za-z_-]+$/, "").trim() + ` v${version}`}</dc:title>`

  props = props.replace(titleFind, titleReplace)
  addin.file('docProps/core.xml', props)

  console.log(`[${filename}] Updating from ${versionString} to ${version}`)
  !dryRun && await new Promise((resolve, reject) => {
    addin.generateNodeStream({ type: 'nodebuffer', streamFiles: true, compression: 'DEFLATE' })
      .pipe(fs.createWriteStream(filename))
      .on('error', (err) => reject(err))
      .on('finish', () => resolve())
  })
}

run().catch((e) => {
  console.error(e)
  process.exit(1)
})

const promised = (parser) => {
  parser.parseAsync = (xml) => new Promise((resolve, reject) => {
    parser.parseString(xml, (err, res) => err ? reject(err) : resolve(res))
  })
  return parser
}

const getAddress = (book, name) => {
  return book.workbook.definedNames[0].definedName
    .filter((n) => n.$.name === name)
    .map((n) => ({
      sheet: n._.split('!')[0],
      cell: n._.split('!')[1].replace(/\$/g, '')
    }))
    .pop()
}
